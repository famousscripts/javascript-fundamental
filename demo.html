<script>
  /*   
  const arr = [1,2,4];
    array iteration
    arr.forEach(item => {
        console.log(item);
    })
    */

   /* array filter
   const filtered = arr.filter(num => num > 5);
   filtered.forEach(newitem => {
       console.log(newitem);
   })
   */

  /*array map
  const mapval = arr.map(num => num+1);
  mapval.forEach(mapitem => {
      console.log(mapitem);
  })
  */
 /*
 sum of array value.
 const sum = arr.reduce((total, value) => total + value, 0);
 console.log(sum);
 */
/*
const arr = [1, 2, 3, 4, 5, 6];

// at least one element is greater than 4?
const largeNum = arr.some(num => num > 4);
console.log(largeNum); // output: true

// at least one element is less than or equal to 0?
const smallNum = arr.some(num => num <= 0);
console.log(smallNum); // output: false
*/
/*
This method check if all array's item passed the condition. If passed, it return 'true' otherwise 'false'.

  const arr = [1, 2, 3, 4, 5, 6];

  // all elements are greater than 4

  const greaterFour = arr.every(num => num > 4);
  console.log(greaterFour); // output: false

  // all elements are less than 10

  const lessTen = arr.every(num => num < 10);
  console.log(lessTen); // output: true

  8. sort()

This method used to arrange/sort array's item either ascending or descending order.

  const arr = [1, 2, 3, 4, 5, 6];
  const alpha = ['e', 'a', 'c', 'u', 'y'];

  // sort in descending order

  descOrder = arr.sort((a, b) => a > b ? -1 : 1);
  console.log(descOrder); // output: [6, 5, 4, 3, 2, 1]

  // sort in ascending order

  ascOrder = alpha.sort((a, b) => a > b ? 1 : -1);
  console.log(ascOrder); // output: ['a', 'c', 'e', 'u', 'y']


  // Slitiing the string into charachter

 const strval = 'ghanshyam';
 const newStr = Array.from(strval);
 console.log(newStr);
 newStr.forEach(stritem => {
    console.log(stritem);
 })


 // Converting the values into array

 const arrnew = Array.of(2,4,5,7,8)
 console.log(arrnew); 

 join()
Joins all elements of an array into a string.

  
   
         var arr = new Array("First","Second","Third");
         
         var str = arr.join();
         document.write("str : " + str ); 
         
         var str = arr.join(", ");
         document.write("<br />str : " + str ); 
         
         var str = arr.join(" + ");
         document.write("<br />str : " + str ); 
 
Output
str : First,Second,Third
str : First, Second, Third
str : First + Second + Third 

array.slice( begin [,end] );


 var arr11 = ["orange", "mango", "banana", "sugar", "tea"];
 var newarr = arr11.slice(1,-1);
 newarr.forEach(itemone => {
     console.log(itemone);
 })
 

removing the dublicate values -- Type1

const nameval = ['g','a','r','p','a','r'];
var uniq = [...new Set(nameval)];
uniq.forEach(itmv => {
    console.log(itmv);
})


removing the dublicate values -- Type2

let array_with_duplcates = ['DELHI','NEWYORK','DELHI','GOA','MUMBAI','CALIFORNIA','GOA'];

function removeDuplicates(arr){
    let unique_array = []
    for(let i = 0;i < arr.length; i++){
        if(unique_array.indexOf(arr[i]) == -1){
            unique_array.push(arr[i])
        }
    }
    return unique_array
}

console.log(removeDuplicates(array_with_duplcates)); // [ 'DELHI', 'NEWYORK', 'GOA', 'MUMBAI', 'CALIFORNIA' ]

var arr = ["orange", "mango", "banana", "sugar", "tea"];  
var removed = arr.splice(2, 0, "water"); 

o/P : After adding 1: orange,mango,water,banana,sugar,tea 


var months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// inserts at 1st index position
console.log(months);
// expected output: Array ['Jan', 'Feb', 'March', 'April', 'June']

months.splice(4, 1, 'May');
// replaces 1 element at 4th index
console.log(months);
// expected output: Array ['Jan', 'Feb', 'March', 'April', 'May']


var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2, 0, 'drum');

// myFish is ["angel", "clown", "drum", "mandarin", "sturgeon"] 
// removed is [], no elements removed


var myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];
var removed = myFish.splice(3, 1);

// removed is ["mandarin"]
// myFish is ["angel", "clown", "drum", "sturgeon"]


var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');

// myFish is ["parrot", "anemone", "blue", "trumpet", "sturgeon"] 
// removed is ["angel", "clown"]


var myFish = ['parrot', 'anemone', 'blue', 'trumpet', 'sturgeon'];
var removed = myFish.splice(myFish.length - 3, 2);

// myFish is ["parrot", "anemone", "sturgeon"] 
// removed is ["blue", "trumpet"]


var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(-2, 1);

// myFish is ["angel", "clown", "sturgeon"] 
// removed is ["mandarin"]

var a;
a + 2;  // Evaluates to NaN


var n = null;
console.log(n * 32); // Will log 0 to the console

if (true) {
  var x = 5;
}
console.log(x);  // x is 5

if (true) {
  let y = 5;
}
console.log(y);  // ReferenceError: y is not defined

Example 1

 var x;
console.log(x === undefined); // true
x = 3;
 

Example 2

var myvar = 'my value';
 
(function() {
  var myvar;
  console.log(myvar); // undefined
  myvar = 'local value';
})();

 Function declaration 

foo(); // "bar"

function foo() {
  console.log('bar');
}



var baz = function() {
  console.log('bar2');
};
baz(); // OK


baz(); // type erro this is not a function
var baz = function() {
  console.log('bar2');
};

Another unusual thing about variables in JavaScript is that you can refer to a variable declared later, without getting an exception. 
This concept is known as hoisting; variables in JavaScript are in a sense "hoisted" or lifted to the top of the function or statement. 
However, variables that are hoisted return a value of undefined.
So even if you declare and initialize after you use or refer to this variable, it still returns undefined.

Function hoistingSection:
For functions, only the function declaration gets hoisted to the top and not the function expression.

// Function declaration

foo(); // "bar"

function foo() {
  console.log('bar');
}


// Function expression

baz(); // TypeError: baz is not a function

var baz = function() {
  console.log('bar2');
};



// Finding the largest value from the array

var arr = [3, 6, 2, 56, 32, 5, 89, 32];
var largest = arr[0];

for (var i = 0; i < arr.length; i++) {
    if (largest < arr[i] ) {
        largest = arr[i];
    }
}
console.log(largest);


// Finding the smallest value from the array
var arr = [3, 6, 2, 56, 32, 5, 89, 32];
var smallest = arr[0];

for (var i = 0; i < arr.length; i++) {
    if (smallest > arr[i] ) {
        smallest = arr[i];
    }
}
console.log(largest);


// One alternative also 

var numbers = [1, 2, 3, 4];
Math.max.apply(null, numbers) // 4
Math.min.apply(null, numbers) // 1


var numbers = [1, 2, 3, 4];
Math.max(...numbers) // 4
Math.min(...numbers) // 1

A simpler, ES2015 way of accomplishing this is with the new spread operator.

//Array to string

  var fruits = ["Banana", "Orange", "Apple", "Mango"];
  fruits.toString();


  String to array 

   var str = "How are you doing today?";
  var res = str.split(" ");

// String reverse 
function reverse(str){
  let reversed = "";
  for(let char123 of str){
    reversed = char123 + reversed;
  }
  console.log(reversed);
}

reverse("ABC");

function reverse(str){
  console.log(str.split("").reverse().join(""));
}
reverse('PQR');

function reverse(str){
  console.log([...str].reverse().join(''));
}
reverse('GHAN');

By reduce method

function reverse(str){
  return str.split("").reduce((rev, char)=> char + rev, ''); 
}


// Json to array
var strjson  = {"0":"1","1":"2","2":"3","3":"4"};
var arr32 = Object.values(strjson);
console.log(arr32);

// Array to json
var fruits = ["Banana", "Orange", "Apple", "Mango"];
var jsonString = JSON.stringify(fruits);
console.log(jsonString);

// Check prime no
function isPrime(num) {
  for(var i = 2; i < num; i++)
    if(num % i === 0) return false;
  console.log("yes prime");
}

isPrime(17);


// last index of string
var myString="JavascriptQuestions";
console.log(myString.length-1);

Explain Event bubbling and Event Capturing in JavaScript?
A: 
Event bubbling and capturing are two ways of event propagation in the HTML DOM API, when an event occurs in an element inside another element, and both elements have registered a handle for that event. The event propagation mode determines in which order the elements receive the event.

With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements.

With capturing, the event is first captured by the outermost element and propagated to the inner elements.

Capturing is also called "trickling", which helps remember the propagation order:

trickle down, bubble up

Back in the old days, Netscape advocated event capturing, while Microsoft promoted event bubbling. Both are part of the W3C Document Object Model Events standard (2000).

IE < 9 uses only event bubbling, whereas IE9+ and all major browsers support both. On the other hand, the performance of event bubbling may be slightly lower for complex DOMs.

We can use the addEventListener(type, listener, useCapture) to register event handlers for in either bubbling (default) or capturing mode. To use the capturing model pass the third argument as true.

Example
<div>
    <ul>
        <li></li>
    </ul>
</div>
In the structure above, assume that a click event occurred in the li element.

In capturing model, the event will be handled by the div first (click event handlers in the div will fire first), then in the ul, then at the last in the target element, li.

In the bubbling model, the opposite will happen: the event will be first handled by the li, then by the ul, and at last by the div element.

What is Javascript BOM?
BOM stands for “Browser Object Modal” that allows Javascript to ‘talk’ to the browser, no standards, modern browsers implement similar BOMS – window, screen, location, 
history, navigator, timing, cookies.


//How to calculate Fibonacci numbers in JavaScript?
Calculating Fibonacci series in JavaScript
Fibonacci numbers are a sequence of numbers where each value is the sum of the previous two, starting with 0 and 1. The first few values are 0, 1, 1, 2, 3, 5, 8, 13 ,…,

function fib(n) {
	var a=0, b=1;
	for (var i=0; i < n; i++) {
		var temp = a+b; 
		a = b;
		b = temp;
	}
	return a;
}


How to add/remove properties to object dynamically in Javascript?

A:  let user = new Object();
    // adding a property
    user.name='Anil';
    user.age  =25;
    console.log(user);
    delete user.age;
    console.log(user);


Q: How to clone an object in Javascript?
A: Object.assign() method is used for cloning an object in Javascript.Here is sample usage

	var x = {myProp: "value"};
    var y = Object.assign({}, x); 
    
Q: List different ways of empty an array in Javascript?
In Javascript, there are many ways to empty an array in Javascript, below we have listed 4 major

By assigning an empty array.

var arr1 =[1,4,5,6];
arr1=[];
By assigning array length to 0.

var arr2 =[1,4,5,6];
arr2.length=0;
By poping the elements of the array.

var arr2 =[1,4,5,6];
while(arr.length > 0) {
    arr.pop();
}
By using .splice() .

var arr =[1,4,5,6];
arr.splice(0,arr.length)  


Q: Explain few difference between null, undefined or undeclared JavaScript variable?
Null is a value that can be assigned to a variable or an object.

Undefined means a variable has been declared but no value is assigned to it. This type of variable is declared itself to be undefined.

Undeclared means the variable has declared without any datatype.

Null, Undefined are primitive data types whereas Undeclared is not a primitive data type.


Q: How to redirect a page to another page in Javascript?
There are several ways to redirect page to another page in JavaScript. These are:

Using location.href: It is the first approach to redirect page. In this, we can go back to access the original document. Syntax:window.location.href =“https://www.onlineinterviewquestions.com/”
Using location.replace: Another approach to redirect page. In this, it is not possible to navigate back to the original document by clicking on the back button as it removes the URL of the original document.
 Syntax: window.location.replace(" https://www.onlineinterviewquestions.com/;");

Q : What are the different types of errors available in JavaScript?
There are three types of errors available in JavaScript

Load time errors: Errors which come up when loading a web page like improper syntax errors are known as Load-time errors and it generates the errors dynamically.
Run time errors: Errors that come due to misuse of the command inside the HTML language.
Logical Errors: These are the errors that occur due to the bad logic performed on a function which is having a 
*/
	
	
	
</script>


Some other Angular related 

Angular 

Q: What's new in Angular 6 and why shall we upgrade to it?
Angular Elements - Angular Elements is a project that lets you wrap your Angular components as Web Components and embed them in a non-Angular application.
New Rendering Engine: Ivy - increases in speed and decreases in application size.
Tree-shakeable providers - a new, recommended, way to register a provider, directly inside the @Injectable() decorator, using the new providedIn attribute
RxJS 6 - Angular 6 now uses RxJS 6 internally, and requires you to update your application also. RxJS released a library called rxjs-compat, that allows you to bump RxJS to version 6.0 even if you, or one of the libraries you’re using, is still using one of the “old” syntaxes.
ElementRef<T> - in Angular 5.0 or older, is that the said ElementRef had its nativeElement property typed as any. In Angular 6.0, you can now type ElementRef more strictly.
Animations - The polyfill web-animations-js is not necessary anymore for animations in Angular 6.0, except if you are using the AnimationBuilder.
i18n - possibility to have “runtime i18n”, without having to build the application once per locale.

Q: You have an HTML response I want to display. How do I do that? 	
A: The correct syntax is the following:
<div [innerHTML]="theHtmlString"></div>

Q:  What is Routing Guard in Angular? 	
A: Angular’s route guards are interfaces which can tell the router whether or not it should allow navigation to a requested route. They make this decision by looking for a true or false return value from a class which implements the given guard interface.

Q:  How can I select an element in a component template? 	
A: You can get a handle to the DOM element via ElementRef by injecting it into your component's constructor:
constructor(myElement: ElementRef) { ... }

Q : What is the difference between *ngIf vs [hidden]? 	
A: *ngIf effectively removes its content from the DOM while [hidden] modifies the display property and only instructs the browser to not show the content but the DOM still contains it.

Q: How would you protect a component being activated through the router? 	
A: The Angular router ships with a feature called guards. These provide us with ways to control the flow of our application. We can stop a user from visitng certain routes, stop a user from leaving routes, and more. The overall process for protecting Angular routes:
Create a guard service: ng g guard auth
Create canActivate() or canActivateChild() methods
Use the guard when defining routes
// import the newly created AuthGuard
const routes: Routes = [
  {
    path: 'account',
    canActivate: [AuthGuard]
  }
];
Some other available guards:
CanActivate: Check if a user has access
CanActivateChild: Check if a user has access to any of the child routes
CanDeactivate: Can a user leave a page? For example, they haven't finished editing a post
Resolve: Grab data before the route is instantiated
CanLoad: Check to see if we can load the routes assets.

Q: How would you run unit test? 	
A: The Angular CLI downloads and install everything you need to test an Angular application with the Jasmine test framework.
The project you create with the CLI is immediately ready to test. Just run this one CLI command:

What is the use of codelyzer in angular 2 application
In Angular2August 7, 2017 pankaj_119
All enterprise applications follows a set of coding conventions and guidelines to maintain code in better way. Codelyzer is an open source tool to run and check whether the pre-defined coding guidelines has been followed or not. Codelyzer does only static code analysis for angular and typescript project.

Codelyzer runs on top of tslint and its coding conventions are usually defined in tslint.json file. Codelyzer can be run via angular cli or npm directly. Editors like Visual Studio Code and Atom also supports codelyzer just by doing a basic settings.

To set up the codelyzer in Visual Studio code, we can go to File -> Preferences -> User Settings and add the path for tslint rules.
{
“tslint.rulesDirectory”: “./node_modules/codelyzer”,
“typescript.tsdk”: “node_modules/typescript/lib”
}
To run from cli: ng lint.

To run from npm: npm run lint


Q: Angular Module Loading:  Eager, Lazy and Preloading
A: This page will walk through Angular module loading example. A module can be loaded eagerly, lazily and preloaded. Eager loading is loading modules before application starts. Lazy loading is loading modules on demand. Preloading is loading modules in background just after application starts. In lazy loading and preloading, modules are loaded asynchronously. 
The application module i.e. AppModule is loaded eagerly before application starts. But the feature modules can be loaded either eagerly or lazily or preloaded. 
Eager loading: To load a feature module eagerly we need to import it into application module using imports metadata of @NgModule decorator. Eager loading is useful in small size applications. In eager loading, all the feature modules will be loaded before the application starts. Hence the subsequent request to the application will be faster.
Lazy loading: To load a feature module lazily we need to load it using loadChildren property in route configuration and that feature module must not be imported in application module. Lazy loading is useful when the application size is growing. In lazy loading, feature module will be loaded on demand and hence application start will be faster. 
Preloading: To preload a feature module we need to load it using loadChildren property and configure preloadingStrategy property with RouterModule.forRoot. That feature module must not be imported in application module. When we assign Angular PreloadAllModules strategy to preloadingStrategy property, then all feature modules configured with loadChildren, are preloaded. To preload selective modules, we need to use custom preloading strategy. We should preload only those features which will be visited by users just after application start and rest feature modules can be loaded lazily. In this way we can improve the performance of our bigger size application. 
In our demo application we have two feature modules CountryModule and PersonModule. We will create three demo applications. In the first application, we will load these feature modules eagerly. In the second application, we will load them lazily and in the third application we will preload them.

Eager Loading
The default loading strategy.
When you’re working with Angular routes, in the beginning, all of your loading is eager. Because without doing anything but including routes in your app, they will default to loading this way. It means everything loads all at once. If you had an app with three sections — home, admin, dashboard — all three would load when the user visits the browser.
Eager loading means the slowest load times for this reason. When you have a small app, this is okay because the total size will not be large enough to see a benefit from the other two loading strategies.

Lazy Loading
The least eager loading strategy.
When you’re lazy, you don’t do anything until you have to. Imagine your app has three sections — home, admin, dashboard. The home section will be accessed all the time and the dashboard section will be accessed most of the time. But the admin section will only be used by a select few users.
You can load the admin route lazily. Until someone clicks to visit the admin section of your app, the code associated with it will not load.
The majority of your users will never load the code for the admin section when using lazy loading, and therefore will access your app faster because it will not need to receive as much code from the server.

Preloading
The somewhere-in-between loading strategy.
When you’re preloading you’re doing the same as lazy loading, but different.
Use home, dashboard, and admin sections for example. Home you always need, so you eager load it. Admin you rarely need, and only a few users need it, so you lazy load it. But dashboard is not the first thing a user sees, so it can wait. But dashboard is something most of your users will want to see at some point so you want it to be ready soon after your home section loads.
After each successful navigation, the router looks in its configuration for an unloaded module that it can preload.


source: Angular Guide on Routing, preloading section
Your home section loads successfully then immediately after it loads, your dashboard section loads in the background. That’s preloading.
The Renderer is a class that is a partial abstraction over the DOM. Using the Renderer for manipulating the DOM doesn't break server-side rendering or Web Workers (where direct access to the DOM would break).
ElementRef is a class that can hold a reference to a DOM element. This is again an abstraction to not break in environments where the browsers DOM isn't actually available.
If ElementRef is injected to a component, the injected instance is a reference to the host element of the current component.
There are other ways to acquire an ElementRef instance like @ViewChild(), @ViewChildren(), @ContentChild(), @ContentChildren(). In this case ElementRef is a reference to the matching element(s) in the template or children.
Renderer and ElementRef are not "either this or that", but instead they have to be used together to get full platform abstraction.

Renderer acts on the DOM and ElementRef is a reference to an element in the DOM the Renderer acts on.
Display middle value of array :
<script>
var arrayItem = [3,4,6,5,9,2,22,11,13];
var middle = arrayItem[Math.round((arrayItem.length-1)/2)];
console.log(middle);
</script>
	
	
In the simplest terms, the tilde matches the most recent minor version (the middle number). 
~1.2.3 will match all 1.2.x versions but will miss 1.3.0.

The caret, on the other hand, is more relaxed. It will update you to the most recent major version (the first number). 
^1.2.3 will match any 1.x.x release including 1.3.0, but will hold off on 2.0.0.
	
